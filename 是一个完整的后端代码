import { connect } from 'cloudflare:sockets';

const E_INVALID_USER = 'invalid user';
const E_INVALID_DATA = 'invalid data';

export default {
	async fetch(request, env, ctx) {
		try {
			const uuid = getUuid(env);
			if (!uuid) {
				return new Response('UUID not configured.', { status: 500 });
			}
			if (!isValidFormat(uuid)) {
				return new Response('Invalid UUID format.', { status: 500 });
			}

			const url = new URL(request.url);
			const path = url.pathname;

			// 订阅请求
			if (path === `/${uuid}/sub`) {
				return handleSubscription(request, uuid);
			}

			// WebSocket 代理请求
			if (request.headers.get('Upgrade') === 'websocket') {
				return await handleWsRequest(request, uuid);
			}

			// 其他请求返回伪装页面
			return new Response('<html><body><h1>404 Not Found</h1></body></html>', {
				status: 404,
				headers: { 'Content-Type': 'text/html' }
			});
		} catch (err) {
			console.error('Worker A error:', err);
			return new Response('Internal Server Error', { status: 500 });
		}
	},
};

// --- 辅助函数 ---
function getUuid(env) {
	const rawToken = env.uuid || env.u || env.UUID || '';
	return rawToken.trim().replace(/^["']|["']$/g, '').toLowerCase();
}

// --- 订阅生成 ---
function handleSubscription(request, uuid) {
	// 优先使用 X-Forwarded-Host（来自 Worker B），否则用原始 Host
	const host = request.headers.get('X-Forwarded-Host') || request.headers.get('Host');
	const url = new URL(request.url);
	const target = url.searchParams.get('target');

	if (target === 'clash') {
		const clashYaml = `mixed-port: 7890
allow-lan: true
mode: rule
log-level: info
proxies:
  - name: "${host}"
    type: vless
    server: ${host}
    port: 443
    uuid: ${uuid}
    network: ws
    tls: true
    udp: true
    ws-opts:
      path: "/?ed=2048"
      headers:
        Host: ${host}
    servername: ${host}
proxy-groups:
  - name: "Proxy"
    type: select
    proxies:
      - "${host}"
rules:
  - GEOIP,CN,DIRECT
  - MATCH,Proxy
`;
		return new Response(clashYaml, {
			status: 200,
			headers: {
				'Content-Type': 'text/yaml;charset=utf-8',
				'Profile-Update-Interval': '24'
			}
		});
	} else {
		const vlessLink = `vless://${uuid}@${host}:443?encryption=none&security=tls&sni=${host}&fp=randomized&type=ws&host=${host}&path=%2F%3Fed%3D2048#${host}`;
		const base64Content = btoa(vlessLink);
		return new Response(base64Content, {
			status: 200,
			headers: {
				'Content-Type': 'text/plain;charset=utf-8',
				'Profile-Update-Interval': '24'
			}
		});
	}
}

// --- WebSocket 处理 ---
async function handleWsRequest(request, uuid) {
	const wsPair = new WebSocketPair();
	const [clientSock, serverSock] = Object.values(wsPair);
	serverSock.accept();

	const context = {
		remoteConnWrapper: { socket: null },
		isDnsQuery: false,
		lastActivity: Date.now()
	};

	const keepAliveTimer = setInterval(() => {
		if (Date.now() - context.lastActivity > 90000) {
			closeSocketQuietly(serverSock);
			if (context.remoteConnWrapper.socket) {
				closeSocketQuietly(context.remoteConnWrapper.socket);
			}
			clearInterval(keepAliveTimer);
		}
	}, 30000);

	serverSock.addEventListener('close', () => clearInterval(keepAliveTimer));
	serverSock.addEventListener('error', () => clearInterval(keepAliveTimer));

	const earlyData = request.headers.get('sec-websocket-protocol') || '';
	const readable = makeReadableStream(serverSock, earlyData, context);

	readable.pipeTo(new WritableStream({
		async write(chunk) {
			context.lastActivity = Date.now();

			if (context.isDnsQuery) {
				return await forwardUDP(chunk, serverSock, null);
			}

			if (context.remoteConnWrapper.socket) {
				const writer = context.remoteConnWrapper.socket.writable.getWriter();
				await writer.write(chunk);
				writer.releaseLock();
				return;
			}

			const { hasError, message, addressType, port, hostname, rawIndex, version, isUDP } = parseWsPacketHeader(chunk, uuid);

			if (hasError) {
				if (message === E_INVALID_USER) {
					const fakeResponse = "HTTP/1.1 404 Not Found\r\nConnection: close\r\nContent-Type: text/html\r\n\r\n<html><body><h1>404 Not Found</h1></body></html>";
					try { serverSock.send(fakeResponse); } catch (e) { }
				}
				serverSock.close();
				return;
			}

			if (isUDP) {
				if (port === 53) {
					context.isDnsQuery = true;
				} else {
					throw new Error("UDP proxy only enabled for DNS (port 53)");
				}
			}

			const respHeader = new Uint8Array([version[0], 0]);
			const rawData = chunk.slice(rawIndex);

			if (context.isDnsQuery) {
				return forwardUDP(rawData, serverSock, respHeader);
			}

			await forwardTCP(addressType, hostname, port, rawData, serverSock, respHeader, context);
		},
	})).catch((err) => {
		clearInterval(keepAliveTimer);
		console.error('WebSocket error:', err);
	});

	return new Response(null, { status: 101, webSocket: clientSock });
}

async function forwardTCP(addrType, host, portNum, rawData, ws, respHeader, context) {
	async function connectAndSend(address, port) {
		const remoteSock = connect({ hostname: address, port: port });
		context.remoteConnWrapper.socket = remoteSock;
		const writer = remoteSock.writable.getWriter();
		await writer.write(rawData);
		writer.releaseLock();
		return remoteSock;
	}

	try {
		const initialSocket = await connectAndSend(host, portNum);
		connectStreams(initialSocket, ws, respHeader, context);
	} catch (err) {
		console.error('TCP connection failed:', err);
		throw new Error('Connection failed to ' + host + ':' + portNum);
	}
}

function parseWsPacketHeader(chunk, token) {
	if (chunk.byteLength < 24) return { hasError: true, message: E_INVALID_DATA };

	const version = new Uint8Array(chunk.slice(0, 1));
	if (formatIdentifier(new Uint8Array(chunk.slice(1, 17))) !== token) {
		return { hasError: true, message: E_INVALID_USER };
	}

	const optLen = new Uint8Array(chunk.slice(17, 18))[0];
	const cmd = new Uint8Array(chunk.slice(18 + optLen, 19 + optLen))[0];

	let isUDP = false;
	if (cmd === 1) {
		// TCP
	} else if (cmd === 2) {
		isUDP = true;
	} else {
		return { hasError: true, message: "command is not supported" };
	}

	const portIdx = 19 + optLen;
	const port = new DataView(chunk.slice(portIdx, portIdx + 2)).getUint16(0);

	let addrIdx = portIdx + 2;
	let addrLen = 0;
	let addrValIdx = addrIdx + 1;
	let hostname = '';

	const addressType = new Uint8Array(chunk.slice(addrIdx, addrValIdx))[0];

	switch (addressType) {
		case 1:
			addrLen = 4;
			hostname = new Uint8Array(chunk.slice(addrValIdx, addrValIdx + addrLen)).join('.');
			break;
		case 2:
			addrLen = new Uint8Array(chunk.slice(addrValIdx, addrValIdx + 1))[0];
			addrValIdx += 1;
			hostname = new TextDecoder().decode(chunk.slice(addrValIdx, addrValIdx + addrLen));
			break;
		case 3:
			addrLen = 16;
			const ipv6 = [];
			const ipv6View = new DataView(chunk.slice(addrValIdx, addrValIdx + addrLen));
			for (let i = 0; i < 8; i++) {
				ipv6.push(ipv6View.getUint16(i * 2).toString(16));
			}
			hostname = ipv6.join(':');
			break;
		default:
			return { hasError: true, message: 'invalid addressType: ' + addressType };
	}

	if (!hostname) {
		return { hasError: true, message: 'addressValue is empty: ' + addressType };
	}

	return {
		hasError: false,
		addressType,
		port,
		hostname,
		isUDP,
		rawIndex: addrValIdx + addrLen,
		version
	};
}

function makeReadableStream(socket, earlyDataHeader, context) {
	let cancelled = false;
	return new ReadableStream({
		start(controller) {
			socket.addEventListener('message', (event) => {
				if (!cancelled) controller.enqueue(event.data);
			});
			socket.addEventListener('close', () => {
				if (!cancelled) {
					closeSocketQuietly(socket);
					controller.close();
				}
			});
			socket.addEventListener('error', (err) => controller.error(err));

			const { earlyData, error } = base64ToArray(earlyDataHeader);
			if (error) {
				controller.error(error);
			} else if (earlyData) {
				controller.enqueue(earlyData);
			}
		},
		cancel() {
			cancelled = true;
			closeSocketQuietly(socket);
		}
	});
}

async function connectStreams(remoteSocket, webSocket, headerData, context) {
	let header = headerData;
	await remoteSocket.readable.pipeTo(new WritableStream({
		async write(chunk) {
			if (context) context.lastActivity = Date.now();
			if (webSocket.readyState !== 1) throw new Error("WebSocket is not open");

			if (header) {
				webSocket.send(await new Blob([header, chunk]).arrayBuffer());
				header = null;
			} else {
				webSocket.send(chunk);
			}
		},
	})).catch((error) => {
		closeSocketQuietly(webSocket);
	});
}

async function forwardUDP(udpChunk, webSocket, respHeader) {
	try {
		const tcpSocket = connect({ hostname: '8.8.4.4', port: 53 });
		let vlessHeader = respHeader;

		const writer = tcpSocket.writable.getWriter();
		await writer.write(udpChunk);
		writer.releaseLock();

		await tcpSocket.readable.pipeTo(new WritableStream({
			async write(chunk) {
				if (webSocket.readyState === 1) {
					if (vlessHeader) {
						webSocket.send(await new Blob([vlessHeader, chunk]).arrayBuffer());
						vlessHeader = null;
					} else {
						webSocket.send(chunk);
					}
				}
			},
		}));
	} catch (error) {
		console.error('DNS forward error:', error.message);
	}
}

function base64ToArray(b64Str) {
	if (!b64Str) return { error: null };
	try {
		b64Str = b64Str.replace(/-/g, '+').replace(/_/g, '/');
		return {
			earlyData: Uint8Array.from(atob(b64Str), (c) => c.charCodeAt(0)).buffer,
			error: null
		};
	} catch (error) {
		return { error };
	}
}

function isValidFormat(uuid) {
	return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(uuid);
}

function closeSocketQuietly(socket) {
	try {
		if (socket.readyState === 1 || socket.readyState === 2) socket.close();
	} catch (error) { }
}

const hexTable = Array.from({ length: 256 }, (v, i) => (i + 256).toString(16).slice(1));

function formatIdentifier(arr, offset = 0) {
	const id = (
		hexTable[arr[offset]] + hexTable[arr[offset + 1]] + hexTable[arr[offset + 2]] + hexTable[arr[offset + 3]] + "-" +
		hexTable[arr[offset + 4]] + hexTable[arr[offset + 5]] + "-" +
		hexTable[arr[offset + 6]] + hexTable[arr[offset + 7]] + "-" +
		hexTable[arr[offset + 8]] + hexTable[arr[offset + 9]] + "-" +
		hexTable[arr[offset + 10]] + hexTable[arr[offset + 11]] + hexTable[arr[offset + 12]] + hexTable[arr[offset + 13]] + hexTable[arr[offset + 14]] + hexTable[arr[offset + 15]]
	).toLowerCase();
	if (!isValidFormat(id)) throw new TypeError("Stringified identifier is invalid");
	return id;
}
